CSCI-352 Project 1
Submitted by:  Ryan Arnold, Gabby Donohue

Question 1: "Try to guess what its ROM BIOS is doing by looking at the first few instructions"

Answer for Question 1: 
The instructions look like they're in BIOS mode trying to prepare the system to load in a bootloader from BIOS (I think). The instructions set up the stack segment and extended stack pointer register, which are used to run a program. Also, doing "make qemu-gdb" tells QEMU to stop just before the processor executes the first instruction, which tells me the first instruction is probably BIOS firmware trying to immediately load in the bootloader. 


Question 2:
Part A) "At what point does the processor first start executing 32-bit code? What exactly causes the switch from 16- to 32-bit mode?"
Part B) "What is the last instruction of the boot loader executed, and what is the first instruction of the kernel it just loaded?"
Part C) "Where is the first instruction of the kernel?"
Part D) "How does the boot loader decide how many sectors it must read in order to fetch the entire kernel from disk? Where does it find this information?"

Answers for Question 2: 
A) The processor first starts executing 32-bit code after the "ljmp $PROT_MODE_CSEG, $protcseg" code into the .code32 section. The "long jump" instruction causes it to officially switch. To first get into protected mode, you have to set bit 0 of the CR0 register before performing the long jump instruction.
B) The last instruction the boot loader executes is "((void (*)(void)) (ELFHDR->e_entry))();" because the e_entry parameter tells the bootmain() where to find the kernel code. The first instruction of the kernel it just loaded is is "entry.S" file, which is "_start = RELOC(entry)" and specifies the ELF starting point for loading in the kernel code. 
C) The first instruction of the kernel is located in entry.S
D) The number of sectors read depends on number of program headers in the ELFHDR, and the size each ph->p_memsz bytes to read in each program header. It finds this information from each program header located in the Executable and Linkable Format Header (ELFHDR). 


Question 3: "Trace through the first few instructions of the boot loader again and identify the first instruction that would break or otherwise do the wrong thing if you were to get the boot loader's link address wrong. Then change the link address in boot/Makefrag to something wrong. Describe what you changed and what the effect was; was the effect what you expected, or something different?"

Answers for Question 3:
1) (*I might be wrong about this rip*) I think the first address that would break would be in boot.S under the "ljmp $PROT_MODE_CSEG, $protcseg" instruction, because the address of "protcseg" symbol differs depending on the link address, which means the jump would jump to a wrong address. 
