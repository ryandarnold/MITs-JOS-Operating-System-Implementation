CSCI-352 Project 1
Submitted by:  Ryan Arnold, Gabby Donohue

Question 1: "Try to guess what its ROM BIOS is doing by looking at the first few instructions"

Answer for Question 1: 
When the system powers on, the CPU begins execution at a fixed address in the ROM BIOS. These instructions are part of the BIOS firmware responsible
for initializing the hardware and loading the boot loader.  The BIOS appears to do an error check, clearing the stack segment register and the stack 
pointer, then loading the physical address of the boot loader into the stack pointer, to execute later. 

Question 2:
Part A) "At what point does the processor first start executing 32-bit code? What exactly causes the switch from 16- to 32-bit mode?"
Part B) "What is the last instruction of the boot loader executed, and what is the first instruction of the kernel it just loaded?"
Part C) "Where is the first instruction of the kernel?"
Part D) "How does the boot loader decide how many sectors it must read in order to fetch the entire kernel from disk? Where does it find this information?"

Answers for Question 2: 
A) The processor first starts executing 32-bit code after the label protcseg. Before switching to protected mode, interrupts are disabled, the global
descriptor table is loaded, and cr0 is set to protection enabled. Ljmp$PROT_MODE_CSEG, $protcseg switches the processor to 32-bit mode starting at the
label protcseg.

B) The last instruction of the boot loader executed is “((void (*)(void)) (ELFHDR->e_entry))();” in boot/main.c. The first instruction of the kernel is 
_start, which is the ELF entry point. 

C) The instruction is located in entry.S at physical address 0x10018.

D) The boot loader determines how many sectors to read from ELFHDR. ELFHDR has a field, e_phnum, which stores the program headers. E_phnum is iterated
on until all sectors are read. 

Question 3: "Trace through the first few instructions of the boot loader again and identify the first instruction that would break or otherwise do the wrong thing if you were to get the boot loader's link address wrong. Then change the link address in boot/Makefrag to something wrong. Describe what you changed and what the effect was; was the effect what you expected, or something different?"

Answer for Question 3:
In boot/Makefrag, line 28 was changed from “...-e start -Ttext 0x7c00 -o… “ to “-Ttext 0x7”. The boot loader breaks at address 0x07c2e, instruction 
ljmp $PROT_MODE_CSEG, $protcseg. This makes sense since protcseg is a label whose address is computed relative to the base address. Changing the 
base address changes the computed address of the label, causing the jump to go to the wrong offset.  

Question 4: "Examine the 8 words of memory at 0x00100000 before the boot loader and after the boot loader."

Answer for Question 4:
0x100000:	0x1badb002	0x00000000	0xe4524ffe	0x7205c766
0x100010:	0x34000004	0x0000b812	0x220f0011	0xc0200fd8
Before the boot loader is run, the 8 words of memory at 0x00100000 are cleared. The boot loader’s main 
responsibility is to load the kernel into
memory, which starts at physical address 0x10000. After the boot loader finishes running, that section of memory
is now occupied by the kernel 
image. When the boot loader enters the kernel, the memory contains the kernel’s first instructions. 

Question 5: "Examine the memory at 0x00100000 and 0xf0100000 before and after movl $eax, %cr0 in the kernel. What 
would be the first instruction that would fail to work if this instruction was commented out?"

Answer for Question 5:
“movl %eax, %cr0” enables paging, which allows the CPU to begin translating virtual addresses to physical memory.
The first instruction that would fail if the mapping weren’t in place is “movl $*bootstacktop), %esp”.  This 
instruction sets up the stack pointer in virtual memory. If paging wasn’t enabled, the values in the stack would 
not be correctly pushed to the correct location in physical memory. 

Question 6:
A) "Explain the interface between printf.c and console.c."

B) "What is printed after "y=" when cprintf("x=%d y=%d", 3); is executed?"

C) "How to change cprintf() to pass a varible number of arguments in declaration order?"

Answers for Question 6:

A) Console.c directly interacts with I/O devices. Printf.c contains functions that format the given input strings
and processes the strings character by character. Once the string is formatted, each character is passed to the 
console using the function cputchar(), which is defined in conole.c. 

B) The random value stored after *ap will be outputted. This is because there is only one argument passed when
two were expected. 

C) cprintf() can be modified to index its arguments by using the address of the first argument and calculating 
the offset of following augmented based on its index.  

Question 7: "Determine where the kernel initalizes its stack, where in memory it is located, how the kernel reserves space for its stack, and the end the reserved area the 
stack pointer is initialized to point to."

Answer for Question 7:
The kernel initializes its stack in the .data section of entry.S at the label bootstack. It reserves space for 
the stack using the directive “.space KSTKSIZE”, where KSTKSIZE defines the size of the kernel stack. The label 
bootstack top is placed at the end of the reserved space to represent top of the stack since the stack grows from
high to low memory.  Bootstacktop is located at the virtual address 0xf0110000.

Question 8: How many 32-bit words does each recursive nestin level of test_backtrace push on the stack, and what are those words?

Answer for Question 8:
Each recursive level of test_backtrace() pushes 5 words onto the stack. The EBP and EBX of the previous call, the parameter (x) passed into test_backtrace, the next argument (x-1) being
passed into the next recursive level of test_backtrace, and the return address. 



