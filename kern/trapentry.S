/* See COPYRIGHT for copyright information. */

#include <inc/mmu.h>
#include <inc/memlayout.h>
#include <inc/trap.h>



###################################################################
# exceptions/interrupts
###################################################################

/* TRAPHANDLER defines a globally-visible function for handling a trap.
 * It pushes a trap number onto the stack, then jumps to _alltraps.
 * Use TRAPHANDLER for traps where the CPU automatically pushes an error code.
 *
 * You shouldn't call a TRAPHANDLER function from C, but you may
 * need to _declare_ one in C (for instance, to get a function pointer
 * during IDT setup).  You can declare the function with
 *   void NAME();
 * where NAME is the argument passed to TRAPHANDLER.
 */
#define TRAPHANDLER(name, num)						\
	.globl name;		/* define global symbol for 'name' */	\
	.type name, @function;	/* symbol type is function */		\
	.align 2;		/* align function definition */		\
	name:			/* function starts here */		\
	pushl $(num);							\
	jmp _alltraps

/* Use TRAPHANDLER_NOEC for traps where the CPU doesn't push an error code.
 * It pushes a 0 in place of the error code, so the trap frame has the same
 * format in either case.
 */
#define TRAPHANDLER_NOEC(name, num)					\
	.globl name;							\
	.type name, @function;						\
	.align 2;							\
	name:								\
	pushl $0;							\
	pushl $(num);							\
	jmp _alltraps

.text

/*
 * Lab 3: Your code here for generating entry points for the different traps.
 */

//NOTE: 'name' is just a symbol!! it doesn't matter what you name it as long as it makes sense!

	//divide error does NOT push an error code
	TRAPHANDLER_NOEC(label__t_divide_NOEC, T_DIVIDE) //0 -divide error does NOT push an error code
	//label__t_divide_NOEC
	TRAPHANDLER_NOEC(label__t_debug_NOEC, T_DEBUG) //1 - no error code

	TRAPHANDLER_NOEC(label__t_nmi_NOEC, T_NMI) //2 - https://wiki.osdev.org/Exceptions
	
	TRAPHANDLER_NOEC(label__t_brkpt_NOEC, T_BRKPT) //3
	TRAPHANDLER_NOEC(label__t_oflow_NOEC, T_OFLOW) //4
	TRAPHANDLER_NOEC(label__t_bound_NOEC, T_BOUND) //5
	TRAPHANDLER_NOEC(label__t_illop_NOEC, T_ILLOP) //6
	TRAPHANDLER_NOEC(label__t_device_NOEC, T_DEVICE) //7

	TRAPHANDLER(label__t_dblflt, T_DBLFLT) //8
				//9 - reserved (not generated by recent processors)
	TRAPHANDLER(label__t_tss, T_TSS) //10
	TRAPHANDLER(label__t_segnp, T_SEGNP) //11
	TRAPHANDLER(label__t_stack, T_STACK) //12
	TRAPHANDLER(label__t_gpflt, T_GPFLT) //13
	TRAPHANDLER(label__t_pgflt, T_PGFLT) //14
			       //15 - reserved
	TRAPHANDLER_NOEC(label__t_fperr_NOEC, T_FPERR) //16
	
	TRAPHANDLER(label__t_align, T_ALIGN) //17 - YES error code
	
	TRAPHANDLER_NOEC(label__t_mchk_NOEC, T_MCHK) //18
	TRAPHANDLER_NOEC(label__t_simderr_NOEC, T_SIMDERR) //19
	
	TRAPHANDLER_NOEC(label__t_syscall_NOEC, T_SYSCALL) //48 -only CPU can push error codes; T_SYSCALL can be ANY #, this means the CPU doesn't
	TRAPHANDLER_NOEC(label__t_default_NOEC, T_DEFAULT) //500

	
	
	
	
/*
 * Lab 3: Your code here for _alltraps
 */

_alltraps:
        #step 1: push struct PushRegs as first step to emulating the TrapFrame like the lab 3 doc says
	
	//NOTE: the trap number is pushed first, then %ds, then %es in struct TrapFrame definition
	//NOTE: GD_KD is only 8 bits

	push %ds 
	push %es
	pushal          //apparently 'pushal' pushes all registers from the PushRegs struct
	movw $GD_KD, %bx //can't load immediate into register unless its the same size??
	movw %bx, %ds
	movw %bx, %es
	pushl %esp
	call trap
	add 4, %esp


